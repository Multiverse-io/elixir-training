# Elixir Training

## Basics - types

What we'll cover in this section includes:

* [ ] Strings and Atoms
* [ ] Booleans
* [ ] Comparison operators
* [ ] Lists and tuples
* [ ] Maps and structs
* [ ] Keyword lists

<!-- livebook:{"break_markdown":true} -->

### Strings and Atoms

https://hexdocs.pm/elixir/String.html
https://hexdocs.pm/elixir/Atom.html

```elixir
"We like strings"
'We only use charlists when working with Erlang libraries!'
name = "Tim"
"We can do string interpolation #{name}"

# Atoms are like symbols in other languages
:atoms_are_not_garbage_collected
# Use atoms for distinct values
:ok
:error
:"stage complete"
```

| QUESTION!                                                                           |
| ----------------------------------------------------------------------------------- |
| When parsing user input is it better to parse to strings, charlists, or atoms? Why? |

<!-- livebook:{"break_markdown":true} -->

### Booleans

```elixir
# and, or --> both require boolean values as inputs
# --> false
true and false
# --> true
true or false
# --> error!!
1 or true

# &&, || --> can handle truthy/falsy values. 
# nil and false are the only falsy values
# --> 1
1 || true
# --> true
true || 1
# --> nil
1 && nil

# Some of the stranger cases...
# --> 1
false or 1
# --> error!!
1 or false
```

### Comparisons

```elixir
# --> true
"a" == "a"
# --> true 
1 == 1.0
# --> false 
1 === 1.0
# --> true 
5.0 <= 10
# --> true. All types can be compared. There is an overall ordering of types:
1 < :atom
# number < atom < reference < function < port < pid < tuple < map < list < bitstring
```

### Lists and Tuples

<!-- livebook:{"break_markdown":true} -->

* Lists are linked lists (each element has a pointer to the next)
  * ![](images/linked-list.jpeg)
  * Prepending elements is fast
  * Looking up an element or getting the length of a list takes time proportional to the list length
  * The built-in List module has some helpful util methods - https://hexdocs.pm/elixir/List.html
* Tuples are stored contiguously in memory
  * Prepending elements or editing is slow (requires the whole tuple to be copied)
  * Looking up an element or getting the length is constant in time (fast!)
  * The built-in Tuple module has some helpful util methods - https://hexdocs.pm/elixir/Tuple.html

```elixir
# A list
[1, 2, 3]
# --> [1, 2, 3] - Syntax for prepending to list
[1 | [2, 3]]
# --> [1, 2, 3, 4]
[1, 2] ++ [3, 4]
```

```elixir
# A tuple
tuple = {:ok, 15, "humans"}
```

| QUESTION!                                                                                                           |
| ------------------------------------------------------------------------------------------------------------------- |
| I want a data structure to store a users name, hair colour, and height - would lists or tuples be more appropriate? |
| I want a data structure to store the messages a user has sent - would lists or tuples be more appropriate?          |

<!-- livebook:{"break_markdown":true} -->

### Maps and Structs

```elixir
map = %{
  "my_key" => "my_value",
  57 => %{"nested_map_key" => "nested_value"},
  :atoms_make_good_keys => "yay!",
  :tricky_case => nil
}

# What are the outputs from each of the following?
IO.inspect(Map.get(map, "my_key"), label: "my_key")
IO.inspect(Map.get(map, "non-existent"), label: "non-existent")
IO.inspect(Map.get(map, "non-existent-defaulted", :my_default), label: "non-existent-defaulted")
IO.inspect(Map.get(map, ":tricky_case"), label: "tricky_case")
IO.inspect(map.tricky_case, label: "tricky_case with dot syntax")
IO.inspect(map.non_existent, label: "non_existent with dot syntax")
IO.inspect(Map.has_key?(map, "non-existent"), label: "has non-existent-key")
```

```elixir
defmodule Human do
  @enforce_keys [:name]
  defstruct name: "", age: 0, height: 0
end

# What's the output for each of these?
%Human{name: "Tim"}
%Human{name: "Tim", age: 20, height: 150}
%Human{age: 20, height: 150}
```

Let's add some functionality to our Human module and contrast how this might look when 
using a struct vs a map...

```elixir
defmodule HumanStruct do
  @enforce_keys [:name]
  defstruct name: "", age: 0, height: 0

  def grow_older(%{age: age} = human) do
    %{human | age: age + 1}
  end

  def grow_taller(%{height: height} = human) do
    %{human | height: height + 10}
  end
end

defmodule HumanMap do
  def grow_older(%{age: age} = human) do
    %{human | age: age + 1}
  end

  def grow_taller(%{height: height} = human) do
    %{human | height: height + 10}
  end
end
```

```elixir
mike = %HumanStruct{name: "Mike", age: 25, height: 180}
mike_2 = mike |> HumanStruct.grow_older() |> HumanStruct.grow_taller()
IO.inspect(mike_2, label: "Mike")

rachel = %{name: "Rachel", age: 48, height: 190}
rachel_2 = rachel |> HumanMap.grow_older() |> HumanMap.grow_taller()
IO.inspect(rachel_2, label: "Rachel")
```

| DISCUSSION!                                                            |
| ---------------------------------------------------------------------- |
| When do you think you should use maps and when should you use structs? |

<!-- livebook:{"break_markdown":true} -->

### Keyword Lists

* Keyword lists are just lists of 2 item tuples where the first element of each tuple is an atom
* They are often used to pass function options in order to give a neat syntax for passing them
* Keyword lists benefit from some syntactic sugar to make using them easier
* The [Keyword module](https://hexdocs.pm/elixir/Keyword.html) has some helpful utils for working with Keyword lists

```elixir
# A keyword list
[{:a, 1}, {:b, 2}]

# Shorthand for a keyword list
[a: 1, b: 2]

defmodule ListUtils do
  def overpowered(list, kw_args) do
  end
end
```

## Pattern matching

## Functions

### Things to cover

* Named functions
* Anonymous functions, when to use, and how to pass named functions
  * The pipe operator (if I can bodge it into the exercise)
* Default args
* Keyword lists
* 'when' qualifier
* pattern matching with multiple function headers

## Modules

## Conditionals (case, cond, if)

## Recursion instead of loops

## Alias, require, import, and use

## Protocols

## Things to read up on outside of this training
