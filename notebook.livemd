# Elixir Training

## Basics - types

What we'll cover in this section includes:

* [x] Strings and Atoms
* [x] Booleans
* [x] Comparison operators
* [x] Lists and tuples
* [x] Maps and structs
* [x] Keyword lists

<!-- livebook:{"break_markdown":true} -->

### Strings and Atoms

https://hexdocs.pm/elixir/String.html
https://hexdocs.pm/elixir/Atom.html

```elixir
"We like strings"
'We only use charlists when working with Erlang libraries!'
name = "Tim"
"We can do string interpolation #{name}"

# Atoms are like symbols in other languages
:atoms_are_not_garbage_collected
# Use atoms for distinct values
:ok
:error
:"stage complete"
```

| QUESTION!                                                                           |
| ----------------------------------------------------------------------------------- |
| When parsing user input is it better to parse to strings, charlists, or atoms? Why? |

<!-- livebook:{"break_markdown":true} -->

### Booleans

```elixir
# and, or --> both require boolean values as inputs
# --> false
true and false
# --> true
true or false
# --> error!!
# 1 or true

# &&, || --> can handle truthy/falsy values. 
# nil and false are the only falsy values
# --> 1
1 || true
# --> true
true || 1
# --> nil
1 && nil

# Some of the stranger cases...
# --> 1
false or 1
# --> error!!
# 1 or false
```

### Comparisons

```elixir
# --> true
"a" == "a"
# --> true 
1 == 1.0
# --> false 
1 === 1.0
# --> true 
5.0 <= 10
# --> true. All types can be compared. There is an overall ordering of types:
1 < :atom
# number < atom < reference < function < port < pid < tuple < map < list < bitstring
```

### Lists and Tuples

<!-- livebook:{"break_markdown":true} -->

* Lists are linked lists (each element has a pointer to the next)
  * ![](images/linked-list.jpeg)
  * Prepending elements is fast
  * Looking up an element or getting the length of a list takes time proportional to the list length
  * The [Enum module](https://hexdocs.pm/elixir/1.12/Enum.html) contains useful methods for lists, maps, and ranges
  * The [Stream module](https://hexdocs.pm/elixir/1.12/Stream.html) contains similar methods, but the lazy equivalents
  * The built-in List module has some helpful util methods - https://hexdocs.pm/elixir/List.html
* [Streams](https://hexdocs.pm/elixir/1.12/Stream.html) are lazy lists, and can be infinite
* Tuples are stored contiguously in memory
  * Prepending elements or editing is slow (requires the whole tuple to be copied)
  * Looking up an element or getting the length is constant in time (fast!)
  * The built-in Tuple module has some helpful util methods - https://hexdocs.pm/elixir/Tuple.html

```elixir
# A list
[1, 2, 3]
# --> [1, 2, 3] - Syntax for prepending to list
[1 | [2, 3]]
# --> [1, 2, 3, 4]
[1, 2] ++ [3, 4]
```

```elixir
# A tuple
tuple = {:ok, 15, "humans"}
```

| QUESTION!                                                                                                           |
| ------------------------------------------------------------------------------------------------------------------- |
| I want a data structure to store a users name, hair colour, and height - would lists or tuples be more appropriate? |
| I want a data structure to store the messages a user has sent - would lists or tuples be more appropriate?          |

<!-- livebook:{"break_markdown":true} -->

### Interlude - the pipe operator!!

The pipe operator is a handy way to pipe the output of a function into another function.
This helps avoid lots of nested functions.

```elixir
defmodule Pipe do
  def add_1(x), do: x + 1
  def times_3(x), do: x * 3
  def minus_n(x, n), do: x - n
end

x = 5

# If I want to add 1, then times 3 without a pipe I need to do something like this:
Pipe.times_3(Pipe.add_1(x))
# Not too bad, but if you have a lot of chained function calls it can get quite cumbersome

# Instead we can use the pipe operator
x |> Pipe.add_1() |> Pipe.times_3()

# If we pipe to a function which takes multiple arguments the piped value is used at the first 
# Â argument
x |> Pipe.minus_n(4)
# Is the same as...
Pipe.minus_n(x, 4)
```

#### Some examples with the Enum and Stream module

* Both modules provide similar methods, but the Stream module has operations which are lazy

```elixir
# This code doesn't output a list! Just a description of transformations we want to do
[1, 2, 3]
|> Stream.map(fn x -> x + 1 end)
|> Stream.map(fn x -> x + 3 end)
```

| QUESTION!                                                     |
| ------------------------------------------------------------- |
| What output would you expect from the following code and why? |

```elixir
nums = [0, 10, 20]

defmodule Add do
  def add_one(x) do
    IO.puts(x)
    x + 1
  end
end

enum_fn = fn nums ->
  nums
  |> Enum.map(&Add.add_one/1)
  |> Enum.map(&Add.add_one/1)
  |> Enum.map(&Add.add_one/1)
end

stream_fn = fn nums ->
  nums
  |> Stream.map(&Add.add_one/1)
  |> Stream.map(&Add.add_one/1)
  |> Stream.map(&Add.add_one/1)
  |> Enum.to_list()
end

IO.puts("Running Enum version")
enum_fn.(nums)
IO.puts("Running Stream version")
stream_fn.(nums)
```

### Maps and Structs

```elixir
map = %{
  "my_key" => "my_value",
  57 => %{"nested_map_key" => "nested_value"},
  :atoms_make_good_keys => "yay!",
  :tricky_case => nil
}

# What are the outputs from each of the following?
Map.get(map, "my_key") |> IO.inspect(label: "my_key")
Map.get(map, "non-existent") |> IO.inspect(label: "non-existent")
Map.get(map, "non-existent-defaulted", :my_default) |> IO.inspect(label: "non-existent-defaulted")
Map.get(map, ":tricky_case") |> IO.inspect(label: "tricky_case")
map.tricky_case |> IO.inspect(label: "tricky_case with dot syntax")
map.non_existent |> IO.inspect(label: "non_existent with dot syntax")
Map.has_key?(map, "non-existent") |> IO.inspect(label: "has non-existent-key")
```

```elixir
defmodule Human do
  @enforce_keys [:name]
  defstruct name: "", age: 0, height: 0
end
```

```elixir
# What's the output for each of these?
%Human{name: "Tim"}
%Human{name: "Tim", age: 20, height: 150}
%Human{age: 20, height: 150}
```

Let's add some functionality to our Human module and contrast how this might look when 
using a struct vs a map...

```elixir
defmodule HumanStruct do
  @enforce_keys [:name]
  defstruct name: "", age: 0, height: 0

  def grow_older(%{age: age} = human) do
    %{human | age: age + 1}
  end

  def grow_taller(%{height: height} = human) do
    %{human | height: height + 10}
  end
end

defmodule HumanMap do
  def grow_older(%{age: age} = human) do
    %{human | age: age + 1}
  end

  def grow_taller(%{height: height} = human) do
    %{human | height: height + 10}
  end
end
```

```elixir
mike = %HumanStruct{name: "Mike", age: 25, height: 180}
mike_2 = mike |> HumanStruct.grow_older() |> HumanStruct.grow_taller()
IO.inspect(mike_2, label: "Mike")

rachel = %{name: "Rachel", age: 48, height: 190}
rachel_2 = rachel |> HumanMap.grow_older() |> HumanMap.grow_taller()
IO.inspect(rachel_2, label: "Rachel")
```

| DISCUSSION!                                                            |
| ---------------------------------------------------------------------- |
| When do you think you should use maps and when should you use structs? |

<!-- livebook:{"break_markdown":true} -->

### Keyword Lists

* Keyword lists are just lists of 2 item tuples where the first element of each tuple is an atom
* They are often used to pass function options in order to give a neat syntax for passing them
* Keyword lists benefit from some syntactic sugar to make using them easier
* The [Keyword module](https://hexdocs.pm/elixir/Keyword.html) has some helpful utils for working with Keyword lists

```elixir
# A keyword list
[{:a, 1}, {:b, 2}]

# Shorthand for a keyword list
[a: 1, b: 2]

defmodule ListUtils do
  def query(list, kw_args \\ []) do
    filter_fns = Keyword.get_values(kw_args, :where)
    order_by = Keyword.get(kw_args, :order_by)

    filtered_list =
      Enum.reduce(filter_fns, list, fn filter_fn, list ->
        Enum.filter(list, filter_fn)
      end)

    Enum.sort(filtered_list, order_by)
  end
end

my_list = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]

res =
  ListUtils.query(
    my_list,
    where: fn x -> rem(x, 2) == 0 end,
    where: fn x -> rem(x, 3) == 0 end,
    order_by: fn x, y -> x > y end
  )

# This is just syntactic sugar for...
ListUtils.query(
  my_list,
  [
    {:where, fn x -> rem(x, 2) == 0 end},
    {:where, fn x -> rem(x, 3) == 0 end},
    {:order_by, fn x, y -> x > y end}
  ]
)

IO.inspect(res, label: "Result")
```

| EXERCISE! |
| --------- |

Write a function that takes 2 arguments - a starting number and a keyword list which can 
contain 2 keywords to_add, to_takeaway. It should return the starting number with the numbers
to_add and to_takeaway added or taken away.

Example usage:

<!-- livebook:{"force_markdown":true} -->

```elixir
MyMath.do_math(5, to_takeaway: 5, to_takeaway: 2, to_add: 8)
# Expected result ---> 6
```

## Pattern matching

Pattern matching can be helpful for:

* extracting values from composite data structures like maps and tuples
* conditional logic

```elixir
{a, b} = {10, 20}
IO.inspect(a, label: "a")
IO.inspect(b, label: "b")

%{e: e} = %{e: 10, f: 15}
IO.inspect(e, label: "e")

[hd | tail] = [1, 2, 3]
IO.inspect(hd, label: "hd")
IO.inspect(tail, label: "tail")

[x, y, z] = [1, 2, 3]
IO.inspect(x, label: "x")
IO.inspect(y, label: "y")
IO.inspect(z, label: "z")
```

```elixir
# When things don't match...
[a, b] = [1, 2, 3]
```

```elixir
# Motivation for the pin operator
x = 10
[x, y, z] = [11, 12, 13]
IO.inspect(x, label: "x")
```

```elixir
# Usage of the pin operator
x = 10
# --> Match Error!
[^x, y, z] = [11, 12, 13]
```

| QUESTION!                                                                         |
| --------------------------------------------------------------------------------- |
| Will the following pattern matches fail or succeed? What value will be set for x? |

```elixir
x = 5
[^x, ^x, x, x] = [5, 5, 6, 7]
```

```elixir
[a | x] = [1, 2, 3]
```

```elixir
{:ok, [x, _, _]} = {:error, [3, 4, 5]}
```

```elixir
# Also known as the robot butt...
[_ | _] = []
```

## Functions

### Things to cover

* [x] Named functions
* [x]  Anonymous functions, when to use, and how to pass named functions
  * [ ]  The pipe operator (if I can bodge it into the exercise)
* [x]  Default args
* [ ]  'when' qualifier
* [ ]  pattern matching with multiple function headers

```elixir
# Named functions
defmodule Fn do
  def add(a, b) do
    a + b
  end

  def add_shorthand(a, b), do: a + b

  def add_defaulted(a \\ 0, b \\ 0), do: a + b
end

IO.inspect(Fn.add(10, 15))
IO.inspect(Fn.add_shorthand(10, 20))
IO.inspect(Fn.add_defaulted())
```

```elixir
# Anonymous functions
add = fn a, b -> a + b end

# Call them with a .
add.(1, 5)

# You can pass anonymous functions as arguments to other functions
# e.g.1
IO.inspect(Enum.map([1, 2, 3], fn x -> x * 2 end), label: "Doubled")
# e.g.2
triple = fn x -> x * 3 end
IO.inspect(Enum.map([1, 2, 3], triple), label: "Tripled")
```

```elixir
# How do we pass named functions as arguments?
defmodule Fn do
  def square(a), do: a * a
end

# You could use an anonymous function that calls your named function
Enum.map([1, 2, 3], fn x -> Fn.square(x) end)

# Neater to use function capture syntax
Enum.map([1, 2, 3], &Fn.square/1)
```

```elixir
# Function capture syntax can also be used as a shorthand for definining anonymous functions
Enum.map([1, 2, 3], &(&1 * &1 * &1))
```

| EXERCISE!                                                                                                                        |
| -------------------------------------------------------------------------------------------------------------------------------- |
| Can you write a function and_then which takes 2 functions as an argument and itself returns a function which combines them both? |

Example usage:

<!-- livebook:{"force_markdown":true} -->

```elixir
combined_fn = Fn.and_then(fn a -> a + 5 end, fn a -> a * 3 end)
combined_fn.(7) # --> (7 + 5) * 3 --> 36
```

| BONUS 1!                                                                                                            |
| ------------------------------------------------------------------------------------------------------------------- |
| Can you neaten up your code by using the [pipe operator](https://elixirschool.com/en/lessons/basics/pipe_operator)? |

| BONUS 2!                                                                                                                                                                                               |
| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| Can you adapt your code to combine any number of function calls by taking a list of functions as the method argument? TIP: Look at the [reduce function](https://hexdocs.pm/elixir/Enum.html#reduce/3) |

<!-- livebook:{"break_markdown":true} -->

| EXERCISE!                                                                                                      |
| -------------------------------------------------------------------------------------------------------------- |
| Can you use the capture syntax to define an anonymous function which takes 3 arguments and adds them together? |

<!-- livebook:{"break_markdown":true} -->

### Multiple function headers

In Elixir we can define the same function multiple times, and put conditions about which 
implementation to use using 2 concepts:

* Guards
* Pattern matching

```elixir
defmodule Guards do
  def double(a)

  def double(a) when is_number(a) do
    a * 2
  end

  # Strings are binaries in Elixir! Read more on the docs ;)
  def double(a) when is_binary(a) do
    a <> a
  end

  def double(a) when is_function(a) do
    fn x -> a.(x) |> a.() end
  end
end

IO.inspect(Guards.double(5), label: "number")
IO.inspect(Guards.double("moo"), label: "string")
doubled_fn = Guards.double(fn x -> x * 2 end)
IO.inspect(doubled_fn.(2), label: "function")
```

```elixir
def PatternMatching do
  def get_favourite_pet(person, pets)

  def get_favourite_pet(_, [_ | _]]) do
    "No pets :("
  end

  def get_favourite_pet(%{name: name} = _person, [%{name: pet_name}} | _]]) do
    "#{pet_name} is #{name}'s favourite pet!"
  end
end
```

## Modules and docs

```elixir
defmodule OuterModule do
  @moduledoc """
  I'm a module that does some stuff
  """
  defmodule InnerModule do
    @doc """
    Adds 2 numbers
    """
    def add(a, b), do: a + b
  end
end

defmodule OuterModule.AnotherInnerModule do
  def subtract(a, b), do: a - b
end

OuterModule.InnerModule.add(1, 2)
OuterModule.AnotherInnerModule.subtract(10, 2)
```

## Control structures (case, cond, if, comprehensions, 'with')

* [Case](https://elixir-lang.org/getting-started/case-cond-and-if.html#case) statement for pattern matching
* [Cond](https://elixir-lang.org/getting-started/case-cond-and-if.html#cond) statements
* [If/else statements](https://elixir-lang.org/getting-started/case-cond-and-if.html#if-and-unless) (and unless)
* [Comprehensions](https://elixir-lang.org/getting-started/comprehensions.html) are helpful for composing operations
* [The with statement](https://elixir-lang.org/getting-started/mix-otp/docs-tests-and-with.html#with) is helpful for chaining operations which might fail

```elixir
db_results = {:ok, [%{name: "Tim", age: 21}]}

case db_results do
  {:ok, []} -> "No data!"
  {:ok, [_ | _] = data} -> data
  {:error, _} -> "Oh no an error!"
end
```

```elixir
cond do
  2 + 2 == 5 -> "This will not be true"
  2 * 2 == 3 -> "Nor this"
  1 + 1 == 2 -> "But this will"
end
```

```elixir
# Note there is no "else if"
if 2 + 2 == 5 do
  "This will not be true"
else
  "But this will"
end
```

```elixir
unless 2 + 2 == 5 do
  "The laws of maths still hold"
end
```

#### Comprehensions

Comprehensions are useful as they allow you to do functions like Enum.map, Enum.filter in a
neater, more concise syntax

```elixir
# A simple example
for(n <- [1, 2, 3, 4], do: n * n)
|> IO.inspect(label: "Simple example")

# Pattern matching example - only keeps elements matching the pattern!
for({:a, num} <- [a: 1, b: 2, c: 3], do: num * 2)
|> IO.inspect(label: "Pattern matching example")

# Example with a filter
for(n <- [1, 2, 3, 4, 5], n <= 3, do: n * 2)
|> IO.inspect(label: "Example with filter")

# Example with multiple lists
for a <- [1, 2, 3],
    b <- [1, 2, 3],
    rem(a, 2) != 0 do
  a * b
end
|> IO.inspect(label: "Example with multiple lists")

# Example with a different enumerable as input 
for({animal, num} <- %{:monkeys => 10, :lions => 26}, do: {animal, num - 2})
|> IO.inspect(label: "Example with filter")

# Outputting to a data structure other than a list
for {key, val} <- [a: 1, b: 2, c: 3], into: %{}, do: {key, val * 2}
```

#### The With statement

<!-- livebook:{"force_markdown":true} -->

```elixir
with 
  {:ok, db_results} <- get_db_data()
  
```

```elixir
defmodule MaybeFailFns do
  def random_fail(), do: Enum.random([true, false])

  def read_file() do
    case random_fail() do
      true -> {:err, "file_does_not_exist"}
      false -> {:ok, "file contents"}
    end
  end

  def parse_file(file_contents) do
    case random_fail() do
      true -> {:err, "cannot parse file"}
      false -> {:ok, "parsed file contents"}
    end
  end

  def write_parsed_output(parsed_file) do
    case random_fail() do
      true -> {:err, "cannot write file"}
      false -> {:ok, "File written successfully!"}
    end
  end
end
```

```elixir
# We want to read a file, parse the output, and then write the output to another file.
# Any of these steps may fail!!! We want to return the final result or the 1st error we get
import MaybeFailFns

# Approach 1 - things we've seen so far:
case read_file() do
  {:err, err} ->
    {:err, err}

  {:ok, file_contents} ->
    case parse_file(file_contents) do
      {:err, err} ->
        {:err, err}

      {:ok, parsed_file_contents} ->
        case write_parsed_output(parsed_file_contents) do
          {:err, err} -> {:err, err}
          {:ok, success_msg} -> {:ok, success_msg}
        end
    end
end
```

| EXERCISE!                                   |
| ------------------------------------------- |
| Use the with statement to neaten things up! |

```elixir
# Approach 2 - use the with to neaten things up!:
import MaybeFailFns
```

## Alias, require, import, and use

### Aliasing Modules and using Import

* Aliasing lets you use a shorter reference for the module name
* Import means you can use the function names directly

```elixir
defmodule Some.Long.Nested.Module do
  def do_stuff(), do: "Stuff!"
end

Some.Long.Nested.Module.do_stuff()
# Or...
alias Some.Long.Nested.Module
Module.do_stuff()
# Or...
alias Some.Long.Nested.Module, as: M
M.do_stuff()

import Some.Long.Nested.Module
do_stuff()
```

| DISCUSSION                                                |
| --------------------------------------------------------- |
| When should we use import and when should we use require? |

<!-- livebook:{"break_markdown":true} -->

### Require

If you want to use macros from a module then you must require that module.

```elixir
defmodule Mac do
  defmacro my_unless(clause, do: expression) do
    quote do
      if(!unquote(clause), do: unquote(expression))
    end
  end
end

require Mac
import Mac

my_unless 1 == 2 do
  IO.puts("Woohoo!!")
end
```

### Use

When you 'use' another module it lets that module inject arbitrary code into your module.
Usually you will rely on the documentation to let you know what it is doing. The Phoenix 
framework makes heavy use of this!

```elixir
defmodule Mac do
  defmacro __using__(_opts) do
    IO.puts("We're using the Mac module!!")

    quote do
      def say_hello(), do: "hello"
    end
  end
end

defmodule UsingMac do
  use Mac

  def my_method, do: say_hello()
end

UsingMac.my_method()
```

## Things to read up on outside of this training

* Protocols
* Macros
* Elixir Processes and OTP
